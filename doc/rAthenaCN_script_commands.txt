//===== rAthenaCN 文檔 =======================================
//= rAthenaCN 腳本指令說明文件
//===== 作者: ================================================
//= rAthenaCN 開發團隊
//===== 最後更新: ============================================
//= 20161005
//===== 文檔簡介: ============================================
//= rAthenaCN 是基於 rAthena 進行二次開發的, 在 rAthena 官方支
//= 持的腳本指令基礎上, rAthenaCN 也拓展了一些腳本指令, 請參閱
//= 下面的說明, 它會重點介紹腳本指令的參數和用法.
//============================================================

腳本指令別名表
--------------

為了兼容一些其他服務端的腳本, 部分腳本指令擁有別名, 使用別名和使用原名的語法和效果是一樣的.

┌──────────────────────────────┬─────────────────────────────┐
│ 指令原名 (推薦使用)          │ 指令的別名                  │
├──────────────────────────────┼─────────────────────────────┤
│ *itemexists                  │ *existitem                  │
├──────────────────────────────┼─────────────────────────────┤
│ *setrenttime                 │ *resume                     │
├──────────────────────────────┼─────────────────────────────┤
│ *getequipexpiretick          │ *isrental                   │
├──────────────────────────────┼─────────────────────────────┤
│ *gethotkey                   │ *get_hotkey                 │
├──────────────────────────────┼─────────────────────────────┤
│ *sethotkey                   │ *set_hotkey                 │
├──────────────────────────────┼─────────────────────────────┤
│ *recalculatestat             │ *statuscalc 或 *status_calc │
├──────────────────────────────┼─────────────────────────────┤
│ *copynpc                     │ *dupnpc                     │
└──────────────────────────────┴─────────────────────────────┘


腳本指令說明
------------

*warpparty2 "<目標地圖名稱>",<x>,<y>,<隊伍編號>,{"<來自的地圖名稱>"};

用法和 warpparty 一樣, 都是將指定隊伍的全部隊員統一傳送到指定的目的地. 如果指定了最後一個參數, 那麼只有位於「來自的地圖名稱」的隊員會被傳送.

兩者之間的區別在於: 
	warpparty 對已經死亡的隊友則無效(死亡的隊友會被留在原地), 而 warpparty2 對已經死亡的隊友有效(會被立刻以 1HP 的血量復活, 並一起被傳送走).

---------------------------------------

*setheaddir <朝向編號>{,<角色編號>};

用於調整角色的腦袋朝向.

朝向編號:
	0為看正前方, 1為向右看, 2為向左看
	
返回值:
	該指令無論成功失敗, 都不會有返回值

---------------------------------------

*setbodydir <朝向編號>{,<角色編號>};

用於調整角色身體的朝向.

朝向編號:
	和NPC的朝向編號一樣, 從 0 到 7 一共8個方位可選擇.
	
返回值:
	該指令無論成功失敗, 都不會有返回值

---------------------------------------

*party_leave {<角色編號>};

用於讓指定的角色立刻退出隊伍.

返回值:
	若指定角色不在線或不在隊伍中, 則返回 0, 成功則返回 1

---------------------------------------

*openbank {<角色編號>};

用於讓指定的角色立刻打開銀行界面(只對擁有賬號隨身銀行的客戶端版本有效).

返回值:
	若指定角色不在線, 則返回 0, 成功則返回 1

---------------------------------------

*instance_users <副本的實例編號>;

用於獲取指定的副本實例中的參與人數.

返回值:
	成功直接返回副本中的人數, 副本不存在或副本中無人存在則返回 0

---------------------------------------

*mesclear;

清空當前NPC的對話框內容, 借此你可以在無需玩家點擊"Next"按鈕的情況下, 使用 mes 指令來刷新對話窗口的內容.

返回值:
	該指令無論成功失敗, 都不會有返回值

---------------------------------------

*cap_value <數值>,<最小值>,<最大值>;

用來確保數值變量不會低於最小值, 超過最大值. 

返回值:
	如果低於最小值則直接返回最小值, 如果超過最大值則直接返回最大值, 如果在兩者之間則原樣返回數值.

---------------------------------------

*mobremove <魔物的GID>;

根據GID移除一個魔物(只是移除, 不會讓魔物死亡), 合適用來編寫副本劇情.

返回值:
	該指令無論成功失敗, 都不會有返回值

---------------------------------------

*getsameipinfo {<"IP地址">};

獲得某個IP在線的玩家數以及玩家的角色編號等信息.

如果執行成功的話, 會賦予以下數組在線玩家的信息:

@sameip_aid[]		使用指定IP在線的玩家賬號編號數組(AccountID)
@sameip_cid[]		使用指定IP在線的玩家角色編號數組(CharID)
@sameip_name$[]		使用指定IP在線的玩家角色名數組

返回值及 @sameip_amount 變量都會賦予目前使用指定IP登錄的玩家個數.

返回值:
	0 表示出錯或此IP地址目前沒有任何玩家在線; 如果大於 0 那麼代表目前使用此 IP 在線的玩家數.

---------------------------------------

*logout <登出理由編號>{,"<角色名稱>"|<賬號編號>|<角色編號>};

使指定的角色立刻登出遊戲(踢下線), 這裡的"登出理由編號"只能做參考, 不同的理由編號會讓客戶端給玩家顯示不同的提示文本(下面的信息會在以後漢化):

	0 = BAN_UNFAIR
	1 = server closed -> MsgStringTable[4]
	2 = ID already logged in -> MsgStringTable[5]
	3 = timeout/too much lag -> MsgStringTable[241]
	4 = server full -> MsgStringTable[264]
	5 = underaged -> MsgStringTable[305]
	8 = Server sill recognizes last connection -> MsgStringTable[441]
	9 = too many connections from this ip -> MsgStringTable[529]
	10 = out of available time paid for -> MsgStringTable[530]
	11 = BAN_PAY_SUSPEND
	12 = BAN_PAY_CHANGE
	13 = BAN_PAY_WRONGIP
	14 = BAN_PAY_PNGAMEROOM
	15 = disconnected by a GM -> if( servicetype == taiwan ) MsgStringTable[579]
	16 = BAN_JAPAN_REFUSE1
	17 = BAN_JAPAN_REFUSE2
	18 = BAN_INFORMATION_REMAINED_ANOTHER_ACCOUNT
	100 = BAN_PC_IP_UNFAIR
	101 = BAN_PC_IP_COUNT_ALL
	102 = BAN_PC_IP_COUNT
	103 = BAN_GRAVITY_MEM_AGREE
	104 = BAN_GAME_MEM_AGREE
	105 = BAN_HAN_VALID
	106 = BAN_PC_IP_LIMIT_ACCESS
	107 = BAN_OVER_CHARACTER_LIST
	108 = BAN_IP_BLOCK
	109 = BAN_INVALID_PWD_CNT
	110 = BAN_NOT_ALLOWED_JOBCLASS
	? = disconnected -> MsgStringTable[3]

返回值:
	該指令無論成功失敗, 都不會有返回值

---------------------------------------

*searcharray <數組變量>,<要查詢的內容>;

查詢數組中第一次出現待查詢內容的索引序號, 使用它來搜索數組內容很方便(用法比較豐富, 以後再舉例細說).

返回值:
	若查不到結果則返回 -1, 否則返回大於等於 0 的序號

---------------------------------------

*getinventorylist {<角色編號>};

在原來返回的數組基礎上, rAthenaCN 新增了以下返回數組:

- @inventorylist_idx[] 用來返回每個道具的背包位置序號.
- @inventorylist_uid$[] 用來返回每個道具的裝備唯一編號(字符串類型數組).

注意:
	背包位置序號每一次登錄、每一次玩家在自己的背包中增刪物品(包括但不限: 
	存倉、存手推車、丟棄、購買和使用道具等操作)都可能會導致背包位置序號有變化. 
	所以請注意在一段連續、玩家不可能會停下來做其他動作的腳本中去使用「背包位置序號」. 
	否則, 只要你在 getinventorylist 之後, 還給玩家空隙去進行道具的增刪, 
	那麼 @inventorylist_idx[] 中的數據將不再可靠.

---------------------------------------

*delinventory <背包位置序號>,<要移除的數量>;

移除指定背包序號指定數量的道具. 

這裡的背包位置序號可以通過 getinventorylist 腳本指令的 @inventorylist_idx[] 數組來獲得.

返回值:
	操作成功則返回 1, 失敗或沒那麼多道具可以刪則返回 0

---------------------------------------

*countinventory <背包位置序號>;

根據指定背包序號, 獲取該道具在背包中的數量.

返回值:
	直接返回物品的數量, 若改背包序號的物品不存在則返回 0

---------------------------------------

*identifybyidx <背包位置序號>;

根據指定的背包序號, 對該道具進行鑒定操作.

返回值:
	該指令無論成功失敗, 都不會有返回值

---------------------------------------

*equipinventory <背包位置序號>;

穿戴指定背包位置的裝備.

這裡的背包位置序號可以通過 getinventorylist 腳本指令的 @inventorylist_idx[] 數組來獲得.

返回值:
	操作操作成功則返回 1, 失敗則返回 0

---------------------------------------

*unequipinventory <背包位置序號>;

脫下指定背包位置的裝備.

這裡的背包位置序號可以通過 getinventorylist 腳本指令的 @inventorylist_idx[] 數組來獲得.

返回值:
	操作操作成功則返回 1, 失敗則返回 0

---------------------------------------

*getinventoryinfo <背包位置序號>,<要查看的信息類型>;

查看指定背包位置的道具信息.

這裡的背包位置序號可以通過 getinventorylist 腳本指令的 @inventorylist_idx[] 數組來獲得.

要查看的信息類型:
	0 	- 物品編號
	1 	- 堆疊數量
	2 	- 裝備的穿戴位置(如果為 0 則表示還沒穿戴在身上, 位置請參考 EQP_* 開頭的常量)
	3 	- 精煉值
	4 	- 是否已經鑒定(1為已鑒定, 0為未鑒定)
	5 	- 屬性(說是屬性, 其實最常用是用來判斷物品是否損壞, 若損壞則返回1, 沒壞則返回 0)
	6 	- 第一個卡槽的卡片編號
	7 	- 第二個卡槽的卡片編號
	8 	- 第三個卡槽的卡片編號
	9 	- 第四個卡槽的卡片編號
	10	- 過期時間(Unix時間戳, 0 表示永不過期)
	11	- 裝備的唯一編號(unique_id) - 注意: 返回字符串類型的變量

注意:
	若你想獲取裝備的唯一編號, 那麼用來存放返回值的必須是一個字符串類型的變量(變量結尾帶$符號),
	如果用來存放返回值的變量是數值類型的話, 那麼拿到的值不是裝備的唯一編號.
	
	.@uid$ = getinventoryinfo(背包序號, 11);	// 正確
	.@uid = getinventoryinfo(背包序號, 11);		// 錯誤
	
返回值:
	失敗則返回 -1, 成功則返回你所查詢的信息的值
	
---------------------------------------

*viewequip <對方的賬號編號>{,<是否強制查看>};

查看指定賬號在線角色的裝備信息(這裡只需要提供賬號編號, 程序會根據賬號編號找到他目前在線的角色).

是否強制查看:
	0	- 如果對方禁止其他玩家查看裝備, 那麼就不查看
	1	- 就算對方禁止其它玩家查看他的裝備, 也強制進行查看

返回值:
	若指定的目標不在線則返回 -1, 若查看成功則返回 1, 若查看失敗(比如對方禁止查看)則返回 0

---------------------------------------

*itemexists <物品編號>;
*itemexists "物品名稱";
*existitem <物品編號>;
*existitem "物品名稱";

確認服務器的 item_db 中是否存在指定物品, 在由玩家輸入一些物品編號來執行功能時, 先使用該指令判斷一下可以防止直接 getitem 或者 delitem 導致地圖服務器終端顯示報錯信息.

返回值:
	若服務器中不存在此道具則返回0, 若物品存在且可疊加則返回"正數"的物品編號, 若不可堆疊則返回"負數"的物品編號.

---------------------------------------

*setrenttime <裝備位置編號>,<增減的時間秒數>{,<角色編號>};
*resume <裝備位置編號>,<增減的時間秒數>{,<角色編號>};

增加/減少指定位置裝備的租賃時間(如果要減少租賃時間的話, 第二個參數請使用負數).

裝備位置編號: 是指 EQI_* 開頭的位置常量.

返回值:
	如果指定的裝備位置無效或者沒有裝備則返回 -1, 返回 0 表示此物品不是租賃道具(永不過期), 如果返回大於 0 的數則表示此物品是租賃道具(返回值就是它被您增減時間之後, 剩餘時間的秒數)	

---------------------------------------

*battleignore <開關標記>{,<角色編號>};

將指定的角色設置為魔物無視狀態(魔物會無視此玩家的存在, 因此不會攻擊該玩家, 或許可以叫無敵狀態), 避免被魔物攻擊.

開關標記:
	0 關閉無視(角色會被魔物看見), 1 打開無視(角色不會被魔物看見, 也不會被攻擊)

返回值:
	該指令無論成功失敗, 都不會有返回值

---------------------------------------

*getequipexpiretick <裝備位置編號>{,<角色編號>};
*isrental <裝備位置編號>{,<角色編號>};

獲得指定位置裝備的租賃到期剩餘秒數.

返回值:
	如果指定的裝備位置無效或者沒有裝備則返回 -1, 返回 0 表示此物品不是租賃道具(永不過期), 如果返回大於 0 的數則表示此物品是租賃道具(返回值就是它剩餘時間的秒數)	

---------------------------------------

*sc_check <狀態編號>{,<gid>};

用於判斷指定的狀態(Buff)是否存在, 並取得狀態參數.

當返回值為1的時候, 可以通過以下變量來讀取狀態的參數:

@sc_val1		狀態的第1個參數(如果是技能對應的狀態的話, 往往這個參數都是技能等級)
@sc_val2		狀態的第2個參數
@sc_val3		狀態的第3個參數
@sc_val4		狀態的第4個參數
@sc_tickleft	狀態的剩餘時間(單位為毫秒)

返回值:
	0 表示玩家身上沒有你指定的狀態(Buff), 1 表示玩家身上擁有你指定的狀態(Buff)

---------------------------------------

*when_pcmove_doevent;

當玩家的角色在下一次移動時, 觸發 OnPCMoveFilter 事件.

注意: 只有當 conf/battle/extend.conf 的 pc_move_event_trigger_type 選項為 1 時, 該腳本指令才會有價值.

返回值:
	該指令無論成功失敗, 都不會有返回值

---------------------------------------

*processhalt;

在部分支持的事件處理腳本中使用後, 能夠在事件腳本結束時, 中斷源代碼的後續邏輯. 
此功能僅供腳本專家們使用, 沒弄明白它的工作邏輯之前, 請慎重使用.

真心話:
	由於事件隊列機制的影響, 這個功能遠比想像的要雞肋, 只是為了兼容一下 SeAr, 能不用就盡量別用吧.

該指令特定情況下會失效:
	該指令的使用流程中, 在使用 processhalt 之前不能出現 sleep、sleep2、next、close2、menu、
	select、prompt、input、progressbar 等會導致腳本暫停的指令, 否則它的中斷效果將失效.
	
	主要原因是: 如果你執行了這些指令, 那麼服務端需要等待客戶端或者玩家做出響應, 
	而一旦出現這種情況服務端會立刻將此事件認為「執行告一段落」, 然後就立刻去判斷是否需要中斷, 
	但是由於你 processhalt 寫在了這些會導致腳本暫停的指令後面, 
	所以在還沒來得及執行 processhalt 的時候服務端就會認為不需要中斷而結束.

失效可能會帶來效果錯亂:
	此外如果錯誤的使用了 processhalt 的執行順序, 也會影響到下一次此事件的觸發效果,
	下一次觸發此事件時不管是否執行過 processhalt, 都會被認為需要中斷.

事件隊列機制的影響說明:
	舉個例子, 我們可能需要使用 processhalt 在特定的情況下中斷 OnPCEquipFilter 事件,
	以達到禁止玩家穿戴裝備的目的. 但是只這麼做是不完善的,  在特定情況下可能完全失效.
	
	為了避免一個玩家同時執行多個腳本帶來的衝突, rAthena 的腳本引擎實現了一個「事件隊列」功能,
	此功能能夠當玩家在執行某個腳本的時候, 將接下來可能需要玩家執行的腳本預先存放到隊列裡面,
	等玩家執行完上個腳本再繼續觸發執行下一個腳本的內容.
	
	這將導致出現一種情況, 如果玩家在和 NPC 對話的情況下去穿戴裝備的話, 
	那麼此時 OnPCEquipFilter 事件將會被放進隊列中而不會立刻執行. 
	您的腳本代碼無法對 OnPCEquipFilter 事件進行 processhalt 處理, 
	進而地圖服務器會認為玩家穿戴裝備這個事情沒有被中斷, 而允許成功穿戴裝備.

支持的事件以及其中斷作用說明請見: doc\rAthenaCN_events.txt

---------------------------------------

*script4each "{<腳本>}",<覆蓋範圍>{,<參數>...};

對指定範圍的玩家執行相同的一段腳本

全服玩家			- script4each "{<腳本>}",0;
指定地圖			- script4each "{<腳本>}",1,"地圖名";
指定區域			- script4each "{<腳本>}",2,"地圖名",中心坐標x,中心坐標y,範圍;
指定玩家所在的隊伍	- script4each "{<腳本>}",3,玩家角色編號;
指定玩家所在的公會	- script4each "{<腳本>}",4,玩家角色編號;
指定區域			- script4each "{<腳本>}",5,"地圖名",坐標x0,坐標y0,坐標x1,坐標y1;
指定隊伍			- script4each "{<腳本>}",6,隊伍編號;
指定公會			- script4each "{<腳本>}",7,公會編號;

注意: 
	如果<腳本>中有使用到大括號的話, 需要在大括號的左側使用 \ 來進行轉義, 例如:
	script4each "{ if (BaseLevel >= 10) \{ getitem 501, 10;\} }",0;

警告:
	目前 script4each 所執行的腳本中, 禁止出現會導致腳本進入暫停狀態的指令.
	比如 sleep、sleep2、next、close2、menu、select、prompt、input、progressbar 等, 他們的特點是執行這些指令時, 
	都需要等待客戶端/玩家返回一定的信息或做出選擇才能繼續往下執行.

返回值:
	該指令無論成功失敗, 都不會有返回值

---------------------------------------

*gethotkey <快捷鍵位置編號>{,<要獲取的數據類型>};
*get_hotkey <快捷鍵位置編號>{,<要獲取的數據類型>};

獲取指定快捷鍵位置的信息, 快捷鍵位置編號必須大於 0 小於等於 MAX_HOTKEYS (這是個常量, 腳本中可以直接使用).

要獲取的數據類型:
	0	- 獲取快捷鍵的類型 (0 表示該位置的快捷鍵上放的是一個物品, 1 表示該位置的快捷鍵上放的是一個技能)
	1	- 獲取技能編號或物品的編號
	2	- 獲取登記在快捷鍵上的技能等級

返回值:
	如果參數不合法則返回 -1, 否則返回的是你想要獲取的數據內容

---------------------------------------

*sethotkey <快捷鍵位置編號>,<快捷鍵的類型>,<物品編號/技能編號>,<技能等級>;
*set_hotkey <快捷鍵位置編號>,<快捷鍵的類型>,<物品編號/技能編號>,<技能等級>;

設置玩家快捷鍵上的內容, 快捷鍵位置編號必須大於 0 小於等於 MAX_HOTKEYS (這是個常量, 腳本中可以直接使用).

快捷鍵的類型:
	0	- 這個快捷鍵位置想放置一個物品 (若使用該值, 則最末尾的"技能等級"參數無意義, 請直接給"技能等級"參數傳 0 )
	1	- 這個快捷鍵位置想放置一個技能

返回值:
	設置成功則返回 1, 設置失敗則返回 0

---------------------------------------

*bonus_script_remove "<要移除的腳本代碼>"{,<角色編號>};

移除指定的 bonus_script 效果

---------------------------------------

*setpolicyid <行為策略編號>{,<角色編號>};

設置指定玩家的行為策略編號, 配合 conf/policies.conf 中定義的規則來使用.

行為策略編號:
	即在 conf/policies.conf 定義的 policy_id 編號.

返回值:
	設置成功則返回 1, 設置失敗則返回 0

---------------------------------------

*getpolicyid {<角色編號>};

獲得指定玩家的行為策略編號, 配合 conf/policies.conf 中定義的規則來使用.

返回值:
	設置成功則返回行為策略編號, 設置失敗則返回 -1

---------------------------------------

*getpolicyinfo <行為策略信息編號>{,<角色編號>};

獲得指定玩家當前的行為策略詳情, 配合 conf/policies.conf 中定義的規則來使用.

行為策略信息編號(與 conf/policies.conf 中的字段對應):
	0	- base_exp_rate
	1	- job_exp_rate
	2	- drop_rate
	3	- look_head_top
	4	- bind_group_id

返回值:
	成功則獲得你想要查詢的信息的值, 失敗則返回 -1

---------------------------------------

*setchartitle <稱號ID>{,<角色編號>};

設置指定玩家的稱號ID, 該指令只在客戶端版本號大於等於 20150513 的時候有效.

稱號ID:
	這個稱號的ID在客戶端的 data\luafiles514\lua files\datainfo\titletable.lub 中獲取. 例如: 1000

返回值:
	設置成功則返回 1, 設置失敗則返回 0

---------------------------------------

*getchartitle {<角色編號>};

獲得指定玩家的稱號ID, 該指令只在客戶端版本號大於等於 20150513 的時候有效.

返回值:
	設置成功則返回目標玩家的稱號ID(若為 0 則表示此玩家沒有稱號), 設置失敗則返回 -1

---------------------------------------

*query_multidb "拓展數據庫的連接名稱","SQL查詢語句"{, <數組變量1>{, <數組變量2>{, ...}}};

對拓展數據庫執行SQL查詢, 用法和 query_sql 類似, 只是多了一個"拓展數據庫的連接名稱"參數, 用來指定要操作的拓展數據庫.

拓展數據庫的定義:
	在默認情況下, rAthena 提供的腳本指令只能操作主數據庫(query_sql)和日誌數據庫(query_logsql), 但如果我們需要操作第三個數據庫(比如 DiscuzX 論壇數據庫) 的時候, rAthena 自帶的指令就無能為力了. 為了拓展腳本的能力, rAthenaCN 能夠允許你通過 conf/multidb_athena.conf 配置文件來定義拓展數據庫, 並使用 query_multidb 對其進行操作.

返回值:
	與 query_sql、query_logsql 類似, 不再敷述

---------------------------------------

*recalculatestat;
*statuscalc;
*status_calc;

該指令的原名 recalculatestat 是 rAthena 的官方自帶腳本指令, 在此為了兼容一些腳本, 賦予了 statuscalc 和 status_calc 兩個別名給它.

---------------------------------------

*getequipidx <裝備位置編號>,{<角色編號>};

用來獲取穿戴在指定位置的裝備的「背包位置序號」.

注意: 「裝備位置編號」和 getequipid 一樣, 是 EQI_* 開頭的常量(而不是 EQP_* 開頭的常量).

返回值:
	-1	- 在指定的位置找不到裝備
	-2	- 裝備位置編號無效
	-3	- 指定的角色編號無效或者目標玩家不在線
	其他大於等於 0 的數值, 則表示成功, 返回值就是所查位置裝備的「背包位置序號」.

---------------------------------------

*getoptionitem <item id>,<amount>,<identify>,<refine>,<attribute>,<card1>,<card2>,<card3>,<card4>,<Random Option 字符串數組>{,<account ID>};
*getoptionitem "<item name>",<amount>,<identify>,<refine>,<attribute>,<card1>,<card2>,<card3>,<card4>,<Random Option 字符串數組>{,<account ID>};

[指令棄用聲明]
該指令於 '2017-05-13' 開始被聲明棄用, 在未來版本中可能隨時會被移除.
您應該使用 rAthena 官方新提供的 getitem3 指令來替代它, 詳細用法請見: doc\script_commands.txt

根據你提供的一個「Random Option 字符串數組」, 創造出帶有指定 Random Option 的道具到玩家的背包中(注意, 如果創造的道具不是「裝備」類型的道具, 那麼<Random Option 字符串數組>字段將被無視).

單個數組元素的格式:
	<id>|<value>|<param>
	
<Random Option 字符串數組> 的初始化示例:
	setarray .@opt$[0], 
		"RDMOPT_VAR_MAXHPAMOUNT|10000|0",
		"RDMOPT_VAR_MAXSPAMOUNT|10000|0";
	
注意: <Random Option 字符串數組> 的元素長度最大不能超過 5 個, 超過的部分將被無視.

返回值:
	該指令無論成功失敗, 都不會有返回值. 有錯誤會直接輸出到地圖服務器的終端窗口中.

例如, 要創造一個擁有「最大HP增加20000」拓展屬性的短劍, 那麼腳本代碼如下:

	setarray .@opt$[0], 
		"RDMOPT_VAR_MAXHPAMOUNT|20000|0";
		
	getoptionitem 1201,1,1,0,0,0,0,0,0,.@opt$;

---------------------------------------

*readoptarray(<Random Option 字符串數組>,<第幾個Option>,<要讀取的數據類型>);

[指令棄用聲明]
該指令於 '2017-05-13' 開始被聲明棄用, 在未來版本中可能隨時會被移除.

快速從 Random Option 字符串數組中讀取指定的內容.

要讀取的數據類型:
	ROA_ID - 隨機屬性的ID, 要和 db/re/item_randomopt_db.txt 中的對應
	ROA_VALUE - 隨機屬性的值
	ROA_PARAM - 隨機屬性的參數(這個參數的作用取決於item_randomopt_db.txt中如何使用ROA_PARAM, 目前看來所有官方的隨機屬性都沒有用到這個參數)

現在舉例說明如何快速的從一個<Random Option 字符串數組>中讀取想要的內容:

	setarray .@opt$[0], 
		"RDMOPT_VAR_MAXHPAMOUNT|10000|0",
		"RDMOPT_VAR_MAXSPAMOUNT|5000|0";
	
	// 讀取 .@opt$ 中索引為 1 (第二個元素)的 ROA_VALUE 的值
	.@result = readoptarray(.@opt$,1,ROA_VALUE);		// .@result = 5000
	
	// 讀取 .@opt$ 中索引為 0 (第一個元素)的 ROA_ID 的值
	// 這裡不會返回常量字符串 RDMOPT_VAR_MAXHPAMOUNT, 
	// 而是根據 const.txt 中的定義返回 RDMOPT_VAR_MAXHPAMOUNT 對應的數值 1
	.@result = readoptarray(.@opt$,0,ROA_ID);		// .@result = 1

返回值:
	正常的話能返回所需要的內容, 出錯則返回 -1

---------------------------------------

*writeoptarray(<Random Option 數組>,<第幾個Option>,<要修改的數據類型>,<新的值>);

[指令棄用聲明]
該指令於 '2017-05-13' 開始被聲明棄用, 在未來版本中可能隨時會被移除.

快速從 Random Option 字符串數組中修改指定的內容.

要修改的數據類型:
	ROA_ID - 隨機屬性的ID, 要和 db/re/item_randomopt_db.txt 中的對應
	ROA_VALUE - 隨機屬性的值
	ROA_PARAM - 隨機屬性的參數(這個參數的作用取決於item_randomopt_db.txt中如何使用ROA_PARAM, 目前看來所有官方的隨機屬性都沒有用到這個參數)

現在舉例說明如何快速的從一個<Random Option 字符串數組>中修改想要的內容:

	setarray .@opt$[0], 
		"RDMOPT_VAR_MAXHPAMOUNT|10000|0",
		"RDMOPT_VAR_MAXSPAMOUNT|5000|0";
	
	// 修改 .@opt$ 中索引為 1 (第二個元素)的 ROA_VALUE 的值為 5121
	.@result = writeoptarray(.@opt$,1,ROA_VALUE,5121);
	
	// 修改 .@opt$ 中索引為 0 (第一個元素)的 ROA_ID 的值為 RDMOPT_VAR_STRAMOUNT
	.@result = writeoptarray(.@opt$,0,ROA_ID,RDMOPT_VAR_STRAMOUNT);

返回值:
	操作成功則返回 1, 失敗則返回 0

---------------------------------------

*getoptionarraybyidx <背包位置序號>,<保存到的目標 Random Option 數組名稱>;

[指令棄用聲明]
該指令於 '2017-05-13' 開始被聲明棄用, 在未來版本中可能隨時會被移除.

給定背包位置序號, 獲取一個用來表示此物品的 Random Option 字符串數組.

例如:
	getoptionarraybyidx 2,.@save_opt$;	// 記住數組是字符串類型的, 結尾要有 $ 符號

返回值:
	操作成功則返回 1, 失敗則返回 0

---------------------------------------

*getoptionarraybypos <裝備位置編號>,<保存到的目標 Random Option 數組名稱>;

[指令棄用聲明]
該指令於 '2017-05-13' 開始被聲明棄用, 在未來版本中可能隨時會被移除.

給定裝備位置編號, 獲取一個用來表示此物品的 Random Option 字符串數組.

裝備位置編號: 是指 EQI_* 開頭的位置常量.

例如:
	getoptionarraybypos EQI_HAND_R,.@save_opt$;	// 記住數組是字符串類型的, 結尾要有 $ 符號

返回值:
	操作成功則返回 1, 失敗則返回 0

---------------------------------------

*resetoptionbyidx <背包位置序號>;

給定背包位置序號, 清空指定物品的 Random Option 內容.

此選項會在 picklog 日誌表中留下道具的變化痕跡.

返回值:
	操作成功則返回 1, 失敗則返回 0

---------------------------------------

*resetoptionbypos <裝備位置編號>;

給定裝備位置編號, 清空指定物品的 Random Option 內容.

裝備位置編號: 是指 EQI_* 開頭的位置常量.

此選項會在 picklog 日誌表中留下道具的變化痕跡.

返回值:
	操作成功則返回 1, 失敗則返回 0

---------------------------------------

*getidxrandomoption(<背包序號>,<Random Option序號>,<要修改的數據類型>{,<角色編號>});

獲取背包序號指定道具的 Random Option 屬性的值.

要修改的數據類型:
	ROA_ID - 隨機屬性的ID, 要和 db/re/item_randomopt_db.txt 中的對應
	ROA_VALUE - 隨機屬性的值
	ROA_PARAM - 隨機屬性的參數(這個參數的作用取決於item_randomopt_db.txt中如何使用ROA_PARAM, 目前看來所有官方的隨機屬性都沒有用到這個參數)

返回值:
	操作成功則返回查詢的值, 失敗則返回 -1, 如果因為請求的<類型>無效而失敗則返回 0

---------------------------------------

*setidxrandomoption(<背包序號>,<Random Option序號>,<id>,<value>,<param>{,<角色編號>});

設置背包序號指定道具的 Random Option 屬性.

如果被設定的道具未被穿戴, 那麼會先告訴客戶端該道具被刪除, 
然後完成對道具的屬性修改後, 再告訴客戶端你獲得了一個新道具, 此時聊天欄會有個提示.

如果被設定的道具已被穿戴, 那麼會先將裝備脫下, 然後告訴客戶端該道具被刪除, 
接著完成對道具的屬性修改後, 再告訴客戶端你獲得了一個新道具, 並自動將裝備穿戴上.

該道具的背包序號不會因為該指令的操作而被修改.

此選項會在 picklog 日誌表中留下道具的變化痕跡.

返回值:
	操作成功則返回 1, 失敗則返回 0

---------------------------------------

*getiteminfo(<物品編號>,<類型>)

在原來類型的基礎上, rAthenaCN 新增了以下類型:

17 - 是否可精煉, 1表示可以精煉, 0表示不能精煉
18 - 交易限制掩碼, 將返回該物品在 item_trade 數據庫中第二列定義的值
19 - 不會因玩家主動使用而被消耗, 1表示是, 0表示否
20 - 不會被技能當做消耗品而消耗, 1表示是, 0表示否
21 - 是否為寵物捕捉道具, 0表示否, 若是則返回能捕獲的魔物編號
22 - 是否在其使用腳本中調用了 callfunc 指令, 1表示是, 0表示否 (復興前版本返回 -1)

---------------------------------------

*copynpc("<複製出來的新NPC所在地圖名稱>,<X坐標>,<Y坐標>,<朝向編號>","duplicate(<來源NPC名稱>)","<複製出來的新NPC名稱>","<角色編號>");

將一個指定的NPC複製到一個新的位置.
主要的參數是4個字符串, 這四個字符串與使用 duplicate 進行靜態複製時候的四個用 %TAB% 分隔的內容是一樣的.

假設有以下NPC, 我們想把它複製一個新的出來:

	prontera,146,99,2    script    PVP管理員::PVPCOPYTEST    917,{
		mes "[PVP管理員]";
		mes "場地正在修理, 請稍後再來...";
		close;
	}

通常的做法是在腳本中, 使用 duplicate 指令進行靜態複製, 如:

	prontera,156,99,2	duplicate(PVPCOPYTEST)	PVP管理員#1	917

現在你可以使用 copynpc 腳本指令, 將上面這一行靜態複製代碼按 %TAB% 分割為4個字段, 然後以字符串形式傳遞給 copynpc 腳本指令, 如:

	copynpc "prontera,156,99,2","duplicate(PVPCOPYTEST)","PVP管理員#1","917";

同時此函數支持返回複製出來的新NPC的GID, 方便你使用 unit 系列指令對其進行操作, 如:

	.@gid = copynpc("prontera,156,99,2","duplicate(PVPCOPYTEST)","PVP管理員#1","917");
	unittalk .@gid, "My GID is : " + .@gid;
	
如果想要複製一個副本中的NPC, 那麼需要在用到地圖名稱的地方使用 instance_mapname 進行轉換, 原始NPC的名稱也需要用 instance_npcname 進行轉換, 如:

	.@w1 = instance_mapname("1@tower") + ",156,99,2";
	.@w2 = "duplicate(" + instance_npcname("PVPCOPYTEST") + ")";
	.@w3 = "PVP管理員#1";
	.@w4 = "917";
	
	copynpc .@w1, .@w2, .@w3, .@w4;

返回值:
	複製成功, 則返回複製出來的新NPC的GID, 失敗則返回 0

---------------------------------------

*getareagid("<地圖名>",<查詢的單位類型>,<x0>,<y0>,<x1>,<y1>,<返回數組>);
*getareagid("<地圖名>",<查詢的單位類型>,<中心坐標x>,<中心坐標y>,<半徑>,<返回數組>);
*getareagid("<地圖名>",<查詢的單位類型>,<返回數組>);

當地圖名為 this 時, 表示為執行腳本的玩家所在的地圖, 此時腳本必須關聯玩家.

查詢的單位類型:
	BL_PC		- 玩家單位
	BL_MOB		- 魔物單位
	BL_PET		- 寵物單位
	BL_HOM		- 人工生命體單位
	BL_MER		- 傭兵單位
	BL_ITEM		- 物品單位 (拿到了也暫時用不上)
	BL_SKILL	- 技能單位 (拿到了也暫時用不上)
	BL_NPC		- NPC單位
	BL_CHAT		- 聊天室單位 (拿到了也暫時用不上)
	BL_ELEM		- 元素精靈單位 (拿到了也暫時用不上)

返回數組:
	填寫一個你希望查到的 GID 存儲的數字類型數組的變量名, 比如 .@gids
	
	注意: 這裡給定的變量名, 務必要考慮執行該指令的時候, 腳本是否關聯了玩家, 
	如果沒有關聯的話需要使用和玩家無關的變量類型, 比如 $@ 開頭的變量
	
舉個例子:
prontera,150,90,4	script	getareagid_test	123,{
	.@result = getareagid("this", BL_NPC, .@gids);
	if (.@result < 0) {
		dispbottom "執行 getareagid 時發生了錯誤, 返回值為: " + .@result;
	}
	
	for (.@i = 0; .@i < .@result; .@i++) {
		dispbottom ".@gids[" + .@i + "] = " + .@gids[.@i] + " NPC名稱為: " + getunitname(.@gids[.@i]);
	}
}

返回值:
	返回大於 0 的數值: 表示找到了單位, 返回的數值為找到的單位個數
	返回 -1 : 指定地圖為 this 但是沒有關聯玩家
	返回 -2 : 給定的地圖名字是無效的, 找不到地圖
	返回 -3 : 傳遞的參數個數不對, 必須是3個、6個或者7個參數
	返回 -4 : 給定的"返回數組"類型不對, 不能是一個字符串或數值常量, 也不能是字符串數組
	返回 -5 : 給定的"返回數組"是一個需要依賴玩家的變量類型, 但是沒有關聯玩家 (比如 . 或 .@ 開頭的數字類型數組)

致謝:
	感謝 「╰ゴ記憶•斑駁〤」 提供實現代碼

---------------------------------------

*sendmail(<收件人角色編號>,"<發送者名稱>","<標題>","<內容>"{,<附件中的金幣>{,<附件一的物品編號>,<附件一的物品數量>{,<附件二的物品編號>,<附件二的物品數量>{,<附件三的物品編號>,<附件三的物品數量>{,<附件四的物品編號>,<附件四的物品數量>{,<附件五的物品編號>,<附件五的物品數量>}}}}}});
*sendmail2(<收件人角色編號>,"<發送者名稱>","<標題>","<內容>"{,<附件中的金幣>{,<附件一的物品編號>,<附件一的物品數量>,<附件一是否已鑒定>,<附件一的精煉值>,<附件一的屬性>,<附件一的第一張卡片>,<附件一的第二張卡片>,<附件一的第三張卡片>,<附件一的第四張卡片>{,<附件二的物品編號>,<附件二的物品數量>,<附件二是否已鑒定>,<附件二的精煉值>,<附件二的屬性>,<附件二的第一張卡片>,<附件二的第二張卡片>,<附件二的第三張卡片>,<附件二的第四張卡片>{,<附件三的物品編號>,<附件三的物品數量>,<附件三是否已鑒定>,<附件三的精煉值>,<附件三的屬性>,<附件三的第一張卡片>,<附件三的第二張卡片>,<附件三的第三張卡片>,<附件三的第四張卡片>{,<附件四的物品編號>,<附件四的物品數量>,<附件四是否已鑒定>,<附件四的精煉值>,<附件四的屬性>,<附件四的第一張卡片>,<附件四的第二張卡片>,<附件四的第三張卡片>,<附件四的第四張卡片>{,<附件五的物品編號>,<附件五的物品數量>,<附件五是否已鑒定>,<附件五的精煉值>,<附件五的屬性>,<附件五的第一張卡片>,<附件五的第二張卡片>,<附件五的第三張卡片>,<附件五的第四張卡片>}}}}}});
*sendmail3(<收件人角色編號>,"<發送者名稱>","<標題>","<內容>"{,<附件中的金幣>{,<附件一的物品編號>,<附件一的物品數量>,<附件一是否已鑒定>,<附件一的精煉值>,<附件一的屬性>,<附件一的第一張卡片>,<附件一的第二張卡片>,<附件一的第三張卡片>,<附件一的第四張卡片>,<附件一的RandomIDArray>,<附件一的RandomValueArray>,<附件一的RandomParamArray>{,<附件二的物品編號>,<附件二的物品數量>,<附件二是否已鑒定>,<附件二的精煉值>,<附件二的屬性>,<附件二的第一張卡片>,<附件二的第二張卡片>,<附件二的第三張卡片>,<附件二的第四張卡片>,<附件二的RandomIDArray>,<附件二的RandomValueArray>,<附件二的RandomParamArray>{,<附件三的物品編號>,<附件三的物品數量>,<附件三是否已鑒定>,<附件三的精煉值>,<附件三的屬性>,<附件三的第一張卡片>,<附件三的第二張卡片>,<附件三的第三張卡片>,<附件三的第四張卡片>,<附件三的RandomIDArray>,<附件三的RandomValueArray>,<附件三的RandomParamArray>{,<附件四的物品編號>,<附件四的物品數量>,<附件四是否已鑒定>,<附件四的精煉值>,<附件四的屬性>,<附件四的第一張卡片>,<附件四的第二張卡片>,<附件四的第三張卡片>,<附件四的第四張卡片>,<附件四的RandomIDArray>,<附件四的RandomValueArray>,<附件四的RandomParamArray>{,<附件五的物品編號>,<附件五的物品數量>,<附件五是否已鑒定>,<附件五的精煉值>,<附件五的屬性>,<附件五的第一張卡片>,<附件五的第二張卡片>,<附件五的第三張卡片>,<附件五的第四張卡片>,<附件五的RandomIDArray>,<附件五的RandomValueArray>,<附件五的RandomParamArray>}}}}}});

使用該指令, 可以給指定的玩家發送一封郵件. 三個不同版本的指令其實只是支持的參數有所不同.

版本區別:
	sendmail 	可以發送簡單的附件(無任何卡片或者精練值的道具, 藥水等)
	sendmail2	可以發送比較複雜的附件(可設定卡片、精煉值等)
	sendmail3	除了卡片和精煉值之外, 還可以支持 Random Options (隨機屬性)

演示腳本:
	關於這一系列的指令使用方法, 可以參考 npc\racn\racn_sendmail.txt 演示腳本

注意事項:
	這一系列的指令不會去嘗試判斷收件人角色編號是否合法, 需要自己做判斷.
	若客戶端不支持RODEX的話, 那麼附件只有第一個會有效.

返回值:
	該指令無論成功失敗, 都不會有返回值

---------------------------------------
